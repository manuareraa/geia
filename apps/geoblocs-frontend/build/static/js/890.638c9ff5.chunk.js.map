{"version":3,"file":"static/js/890.638c9ff5.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/sdk/dist/drop-claim-conditions-6b858f0b.browser.esm.js"],"sourcesContent":["import { utils, BigNumber, constants } from 'ethers';\nimport deepEqual from 'fast-deep-equal';\nimport { aM as resolveAddress, cw as AmountSchema, B as includesErrorMessage, d5 as isNode, cs as ContractWrapper } from './index-42be4209.browser.esm.js';\nimport { y as transformResultToClaimCondition, z as legacyContractModelToAbstract, A as newContractModelToAbstract, C as ClaimEligibility, D as convertQuantityToBigNumber, f as fetchSnapshotEntryForAddress, E as prepareClaim, F as SnapshotFormatVersion, H as processClaimConditionInputs, I as abstractContractModelToLegacy, J as abstractContractModelToNew, K as updateExistingClaimConditions } from './signature-89bf7caf.browser.esm.js';\nimport { i as isNativeToken, C as ContractEncoder } from './fetchCurrencyValue-d99a82ef.browser.esm.js';\nimport { d as detectContractFeature, h as hasFunction } from './contract-appuri-9892f94f.browser.esm.js';\nimport { f as buildTransactionFunction, T as Transaction } from './transactions-8e6a03fc.browser.esm.js';\n\n/**\n * Manages claim conditions for NFT Drop contracts\n * @erc721\n * @public\n */\nclass DropClaimConditions {\n  constructor(contractWrapper, metadata, storage) {\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /** ***************************************\n   * READ FUNCTIONS\n   *****************************************/\n\n  /**\n   * Get the currently active claim condition\n   *\n   * @returns The claim condition metadata\n   */\n  async getActive(options) {\n    const [cc, metadata, tokenDecimals] = await Promise.all([this.get(), this.metadata.get(), this.getTokenDecimals()]);\n    return await transformResultToClaimCondition(cc, tokenDecimals, this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, options?.withAllowList || false);\n  }\n  async get(conditionId) {\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\n      return newContractModelToAbstract(contractModel);\n    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\n      return newContractModelToAbstract(contractModel);\n    } else {\n      throw new Error(\"Contract does not support claim conditions\");\n    }\n  }\n\n  /**\n   * Get all the claim conditions\n   *\n   * @returns The claim conditions metadata\n   */\n  async getAll(options) {\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const [currentStartId, countBn] = await this.contractWrapper.read(\"claimCondition\", []);\n      const startId = currentStartId.toNumber();\n      const count = countBn.toNumber();\n      const conditions = [];\n      for (let i = startId; i < startId + count; i++) {\n        conditions.push(this.get(i));\n      }\n      const [metadata, decimals, ...fetchedConditions] = await Promise.all([this.metadata.get(), this.getTokenDecimals(), ...conditions]);\n      return Promise.all(fetchedConditions.map(c => transformResultToClaimCondition(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));\n    } else {\n      return [await this.getActive(options)];\n    }\n  }\n\n  /**\n   * Can Claim\n   *\n   * @remarks Check if the drop can currently be claimed.\n   *\n   * @example\n   * ```javascript\n   * // Quantity of tokens to check claimability of\n   * const quantity = 1;\n   * const canClaim = await contract.canClaim(quantity);\n   * ```\n   */\n  async canClaim(quantity, addressToCheck) {\n    // TODO switch to use verifyClaim\n    if (addressToCheck) {\n      addressToCheck = await resolveAddress(addressToCheck);\n    }\n    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;\n  }\n\n  /**\n   * For any claim conditions that a particular wallet is violating,\n   * this function returns human readable information about the\n   * breaks in the condition that can be used to inform the user.\n   *\n   * @param quantity - The desired quantity that would be claimed.\n   * @param addressToCheck - The wallet address, defaults to the connected wallet.\n   *\n   */\n  async getClaimIneligibilityReasons(quantity, addressToCheck) {\n    const reasons = [];\n    let activeConditionIndex;\n    let claimCondition;\n    if (addressToCheck === undefined) {\n      try {\n        addressToCheck = await this.contractWrapper.getSignerAddress();\n      } catch (err) {\n        console.warn(\"failed to get signer address\", err);\n      }\n    }\n\n    // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason\n    if (!addressToCheck) {\n      return [ClaimEligibility.NoWallet];\n    }\n    const [resolvedAddress, decimals] = await Promise.all([resolveAddress(addressToCheck), this.getTokenDecimals()]);\n    const quantityWithDecimals = utils.parseUnits(AmountSchema.parse(quantity), decimals);\n    try {\n      claimCondition = await this.getActive();\n    } catch (err) {\n      if (includesErrorMessage(err, \"!CONDITION\") || includesErrorMessage(err, \"no active mint condition\") || includesErrorMessage(err, \"DropNoActiveCondition\")) {\n        reasons.push(ClaimEligibility.NoClaimConditionSet);\n        return reasons;\n      }\n      console.warn(\"failed to get active claim condition\", err);\n      reasons.push(ClaimEligibility.Unknown);\n      return reasons;\n    }\n    if (claimCondition.availableSupply !== \"unlimited\") {\n      const supplyWithDecimals = utils.parseUnits(claimCondition.availableSupply, decimals);\n      if (supplyWithDecimals.lt(quantityWithDecimals)) {\n        reasons.push(ClaimEligibility.NotEnoughSupply);\n        return reasons;\n      }\n    }\n\n    // check for merkle root inclusion\n    const merkleRootArray = utils.stripZeros(claimCondition.merkleRootHash);\n    const hasAllowList = merkleRootArray.length > 0;\n    let allowListEntry = null;\n    if (hasAllowList) {\n      allowListEntry = await this.getClaimerProofs(resolvedAddress);\n      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {\n        // exclusive allowlist behavior\n        reasons.push(ClaimEligibility.AddressNotAllowed);\n        return reasons;\n      }\n      if (allowListEntry) {\n        try {\n          const claimVerification = await this.prepareClaim(quantity, false, decimals, resolvedAddress);\n          let validMerkleProof;\n          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n            // legacy verifyClaimerMerkleProofs function\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.proofs, claimVerification.maxClaimable]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [resolvedAddress, quantity, {\n              proof: claimVerification.proofs,\n              maxQuantityInAllowlist: claimVerification.maxClaimable\n            }]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n            await this.contractWrapper.read(\"verifyClaim\", [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n            await this.contractWrapper.read(\"verifyClaim\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          }\n        } catch (e) {\n          console.warn(\"Merkle proof verification failed:\", \"reason\" in e ? e.reason || e.errorName : e);\n          const reason = e.reason || e.errorName;\n          switch (reason) {\n            case \"!Qty\":\n            case \"DropClaimExceedLimit\":\n              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n              break;\n            case \"!PriceOrCurrency\":\n            case \"DropClaimInvalidTokenPrice\":\n              reasons.push(ClaimEligibility.WrongPriceOrCurrency);\n              break;\n            case \"!MaxSupply\":\n            case \"DropClaimExceedMaxSupply\":\n              reasons.push(ClaimEligibility.NotEnoughSupply);\n              break;\n            case \"cant claim yet\":\n            case \"DropClaimNotStarted\":\n              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);\n              break;\n            default:\n              {\n                reasons.push(ClaimEligibility.AddressNotAllowed);\n                break;\n              }\n          }\n          return reasons;\n        }\n      }\n    }\n    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      let claimedSupply = BigNumber.from(0);\n      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals);\n      try {\n        claimedSupply = await this.getSupplyClaimedByWallet(resolvedAddress);\n      } catch (e) {\n        // no-op\n      }\n      if (allowListEntry) {\n        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, decimals);\n      }\n      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantityWithDecimals))) {\n        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n        return reasons;\n      }\n\n      // if there is no allowlist, or if there is an allowlist and the address is not in it\n      // if maxClaimable is 0, we consider it as the address is not allowed\n      if (!hasAllowList || hasAllowList && !allowListEntry) {\n        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n          return reasons;\n        }\n      }\n    }\n\n    // check for claim timestamp between claims (ONLY FOR LEGACY)\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];\n      if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n        activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [activeConditionIndex, resolvedAddress]);\n      } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n        // check for claim timestamp between claims\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [resolvedAddress]);\n      }\n      const now = BigNumber.from(Date.now()).div(1000);\n      if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {\n        // contract will return MaxUint256 if user has already claimed and cannot claim again\n        if (timestampForNextClaim.eq(constants.MaxUint256)) {\n          reasons.push(ClaimEligibility.AlreadyClaimed);\n        } else {\n          reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\n        }\n        return reasons;\n      }\n    }\n\n    // if not within a browser context, check for wallet balance.\n    // In browser context, let the wallet do that job\n    if (claimCondition.price.gt(0) && isNode()) {\n      const totalPrice = claimCondition.price.mul(BigNumber.from(quantity));\n      const provider = this.contractWrapper.getProvider();\n      if (isNativeToken(claimCondition.currencyAddress)) {\n        const balance = await provider.getBalance(resolvedAddress);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      } else {\n        const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, ERC20Abi, {}, this.storage);\n        const balance = await erc20.read(\"balanceOf\", [resolvedAddress]);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      }\n    }\n    return reasons;\n  }\n\n  /**\n   * Returns allow list information and merkle proofs for the given address.\n   * @param claimerAddress - the claimer address\n   * @param claimConditionId - optional the claim condition id to get the proofs for\n   */\n  async getClaimerProofs(claimerAddress, claimConditionId) {\n    const claimCondition = await this.get(claimConditionId);\n    const merkleRoot = claimCondition.merkleRoot;\n    const merkleRootArray = utils.stripZeros(merkleRoot);\n    if (merkleRootArray.length > 0) {\n      const [metadata, resolvedAddress] = await Promise.all([this.metadata.get(), resolveAddress(claimerAddress)]);\n      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the total supply claimed by a specific wallet\n   * @param walletAddress - the wallet address to check\n   * @returns The total supply claimed\n   */\n  async getSupplyClaimedByWallet(walletAddress) {\n    const resolvedAddress = await resolveAddress(walletAddress);\n    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [resolvedAddress]);\n    }\n    if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const activeClaimConditionId = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [activeClaimConditionId, resolvedAddress]);\n    }\n    throw new Error(\"This contract does not support the getSupplyClaimedByWallet function\");\n  }\n\n  /** ***************************************\n   * WRITE FUNCTIONS\n   *****************************************/\n\n  /**\n   * Set public mint conditions\n   *\n   * @remarks Sets the public mint conditions that need to be fullfiled by users to claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   *\n   * // Optionally specify addresses that can claim\n   * const snapshots = ['0x...', '0x...']\n   *\n   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim\n   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]\n   *\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: snapshots, // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   *\n   * await dropContract.claimConditions.set(claimConditions);\n   * ```\n   *\n   * @param claimConditionInputs - The claim conditions\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  set = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this = this;\n    return async function (claimConditionInputs) {\n      let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let claimConditionsProcessed = claimConditionInputs;\n      if (_this.isLegacySinglePhaseDrop(_this.contractWrapper) || _this.isNewSinglePhaseDrop(_this.contractWrapper)) {\n        resetClaimEligibilityForAll = true;\n        if (claimConditionInputs.length === 0) {\n          claimConditionsProcessed = [{\n            startTime: new Date(0),\n            currencyAddress: constants.AddressZero,\n            price: 0,\n            maxClaimableSupply: 0,\n            maxClaimablePerWallet: 0,\n            waitInSeconds: 0,\n            merkleRootHash: utils.hexZeroPad([0], 32),\n            snapshot: []\n          }];\n        } else if (claimConditionInputs.length > 1) {\n          throw new Error(\"Single phase drop contract cannot have multiple claim conditions, only one is allowed\");\n        }\n      }\n\n      // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well\n      if (_this.isNewSinglePhaseDrop(_this.contractWrapper) || _this.isNewMultiphaseDrop(_this.contractWrapper)) {\n        claimConditionsProcessed.forEach(cc => {\n          if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === \"unlimited\")) {\n            throw new Error(\"maxClaimablePerWallet must be set to a specific value when an allowlist is set.\\n\" + \"Example: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\\n\" + \"contract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])\");\n          }\n          if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === \"0\" && cc.snapshot.map(s => {\n            if (typeof s === \"string\") {\n              return 0;\n            } else {\n              return Number(s.maxClaimable?.toString() || 0);\n            }\n          }).reduce((acc, current) => {\n            return acc + current;\n          }, 0) === 0) {\n            throw new Error(\"maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.\");\n          }\n        });\n      }\n\n      // process inputs\n      const {\n        snapshotInfos,\n        sortedConditions\n      } = await processClaimConditionInputs(claimConditionsProcessed, await _this.getTokenDecimals(), _this.contractWrapper.getProvider(), _this.storage, _this.getSnapshotFormatVersion());\n      const merkleInfo = {};\n      snapshotInfos.forEach(s => {\n        merkleInfo[s.merkleRoot] = s.snapshotUri;\n      });\n      const metadata = await _this.metadata.get();\n      const encoded = [];\n\n      // upload new merkle roots to snapshot URIs if updated\n      if (!deepEqual(metadata.merkle, merkleInfo)) {\n        const mergedMetadata = await _this.metadata.parseInputMetadata({\n          ...metadata,\n          merkle: merkleInfo\n        });\n        // using internal method to just upload, avoids one contract call\n        const contractURI = await _this.metadata._parseAndUploadMetadata(mergedMetadata);\n\n        // TODO (cc) we could write the merkle tree info on the claim condition metadata instead\n        // TODO (cc) but we still need to maintain the behavior here for older contracts\n        if (hasFunction(\"setContractURI\", _this.contractWrapper)) {\n          const contractEncoder = new ContractEncoder(_this.contractWrapper);\n          encoded.push(contractEncoder.encode(\"setContractURI\", [contractURI]));\n        } else {\n          throw new Error(\"Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.\");\n        }\n      }\n      const cw = _this.contractWrapper;\n      const baseContractEncoder = new ContractEncoder(cw);\n      if (_this.isLegacySinglePhaseDrop(cw)) {\n        const contractEncoderLegacy = new ContractEncoder(cw);\n        encoded.push(contractEncoderLegacy.encode(\"setClaimConditions\", [abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (_this.isLegacyMultiPhaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));\n      } else if (_this.isNewSinglePhaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (_this.isNewMultiphaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));\n      } else {\n        throw new Error(\"Contract does not support claim conditions\");\n      }\n      if (hasFunction(\"multicall\", _this.contractWrapper)) {\n        return Transaction.fromContractWrapper({\n          contractWrapper: _this.contractWrapper,\n          method: \"multicall\",\n          args: [encoded]\n        });\n      }\n      throw new Error(\"Contract does not support multicall\");\n    };\n  })());\n\n  /**\n   * Update a single claim condition with new data.\n   *\n   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`\n   * @param claimConditionInput - the new data to update, previous data will be retained\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (index, claimConditionInput) => {\n    const existingConditions = await this.getAll();\n    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);\n    return await this.set.prepare(newConditionInputs);\n  });\n\n  /** ***************************************\n   * PRIVATE FUNCTIONS\n   *****************************************/\n\n  async getTokenDecimals() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return this.contractWrapper.read(\"decimals\", []);\n    } else {\n      return Promise.resolve(0);\n    }\n  }\n\n  /**\n   * Returns proofs and the overrides required for the transaction.\n   *\n   * @returns  `overrides` and `proofs` as an object.\n   * @internal\n   */\n  async prepareClaim(quantity, checkERC20Allowance) {\n    let decimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let address = arguments.length > 3 ? arguments[3] : undefined;\n    const [addressToClaim, activeClaimConditions] = await Promise.all([address ? address : this.contractWrapper.getSignerAddress(), this.getActive()]);\n    return prepareClaim(addressToClaim, quantity, activeClaimConditions, async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());\n  }\n  async getClaimArguments(destinationAddress, quantity, claimVerification) {\n    const resolvedAddress = await resolveAddress(destinationAddress);\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n        proof: claimVerification.proofs,\n        maxQuantityInAllowlist: claimVerification.maxClaimable\n      }, utils.toUtf8Bytes(\"\")];\n    }\n    return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n      proof: claimVerification.proofs,\n      quantityLimitPerWallet: claimVerification.maxClaimable,\n      pricePerToken: claimVerification.priceInProof,\n      currency: claimVerification.currencyAddressInProof\n    }, utils.toUtf8Bytes(\"\")];\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - The address to claim to\n   * @param quantity - The quantity to claim\n   * @param options - Options to override the claim transaction\n   *\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    // TODO: Transaction Sequence Pattern\n    if (options?.pricePerToken) {\n      throw new Error(\"Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`\");\n    }\n    const claimVerification = await this.prepareClaim(quantity, options?.checkERC20Allowance === undefined ? true : options.checkERC20Allowance, await this.getTokenDecimals());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),\n      overrides: claimVerification.overrides\n    });\n  }\n  isNewSinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV2\");\n  }\n  isNewMultiphaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV2\");\n  }\n  isLegacySinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV1\");\n  }\n  isLegacyMultiPhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV1\");\n  }\n  getSnapshotFormatVersion() {\n    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;\n  }\n}\n\nexport { DropClaimConditions as D };\n"],"names":["DropClaimConditions","contractWrapper","metadata","storage","_this2","_classCallCheck","_defineProperty","buildTransactionFunction","_this","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","claimConditionInputs","resetClaimEligibilityForAll","claimConditionsProcessed","_yield$processClaimCo","snapshotInfos","sortedConditions","merkleInfo","encoded","mergedMetadata","contractURI","contractEncoder","cw","baseContractEncoder","contractEncoderLegacy","_args","arguments","wrap","_context","prev","next","length","undefined","isLegacySinglePhaseDrop","isNewSinglePhaseDrop","startTime","Date","currencyAddress","constants","price","maxClaimableSupply","maxClaimablePerWallet","waitInSeconds","merkleRootHash","utils","snapshot","Error","isNewMultiphaseDrop","forEach","cc","_cc$maxClaimablePerWa","toString","map","s","Number","_s$maxClaimable","maxClaimable","reduce","acc","current","t0","processClaimConditionInputs","t1","getTokenDecimals","t2","sent","t3","getProvider","t4","t5","getSnapshotFormatVersion","merkleRoot","snapshotUri","get","deepEqual","merkle","parseInputMetadata","_objectSpread","_parseAndUploadMetadata","hasFunction","ContractEncoder","push","encode","abstractContractModelToLegacy","isLegacyMultiPhaseDrop","abstractContractModelToNew","abrupt","Transaction","fromContractWrapper","method","args","stop","_x","apply","_ref2","_callee2","index","claimConditionInput","existingConditions","newConditionInputs","_context2","getAll","updateExistingClaimConditions","set","prepare","_x2","_x3","this","_createClass","key","value","_getActive","_callee3","options","_yield$Promise$all","_yield$Promise$all2","tokenDecimals","_context3","Promise","all","_slicedToArray","transformResultToClaimCondition","withAllowList","_x4","_get","_callee4","conditionId","contractModel","id","_contractModel","_contractModel2","_id","_contractModel3","_context4","read","legacyContractModelToAbstract","newContractModelToAbstract","_x5","_getAll","_callee5","_yield$this$contractW","_yield$this$contractW2","currentStartId","countBn","startId","count","conditions","i","_yield$Promise$all3","_yield$Promise$all4","decimals","fetchedConditions","_this3","_context5","toNumber","concat","_toArray","slice","c","getActive","_x6","_canClaim","_callee6","quantity","addressToCheck","_context6","resolveAddress","getClaimIneligibilityReasons","_x7","_x8","_getClaimIneligibilityReasons","_callee7","reasons","activeConditionIndex","claimCondition","_yield$Promise$all5","_yield$Promise$all6","resolvedAddress","quantityWithDecimals","merkleRootArray","hasAllowList","allowListEntry","claimVerification","_yield$this$contractW3","_yield$this$contractW4","_yield$this$contractW5","_yield$this$contractW6","reason","claimedSupply","_ref3","lastClaimedTimestamp","timestampForNextClaim","_yield$this$contractW7","_yield$this$contractW8","_yield$this$contractW9","_yield$this$contractW10","now","totalPrice","provider","ERC20Abi","erc20","_context7","getSignerAddress","console","warn","ClaimEligibility","NoWallet","AmountSchema","parse","includesErrorMessage","NoClaimConditionSet","Unknown","availableSupply","lt","NotEnoughSupply","getClaimerProofs","AddressNotAllowed","prepareClaim","proofs","proof","maxQuantityInAllowlist","quantityLimitPerWallet","currency","currencyAddressInProof","pricePerToken","priceInProof","errorName","OverMaxClaimablePerWallet","WrongPriceOrCurrency","ClaimPhaseNotStarted","BigNumber","from","convertQuantityToBigNumber","getSupplyClaimedByWallet","gt","add","lte","eq","div","AlreadyClaimed","WaitBeforeNextClaimTransaction","isNode","mul","isNativeToken","getBalance","NotEnoughTokens","default","ContractWrapper","_x9","_x10","_getClaimerProofs","_callee8","claimerAddress","claimConditionId","_yield$Promise$all7","_yield$Promise$all8","_context8","fetchSnapshotEntryForAddress","_x11","_x12","_getSupplyClaimedByWallet","_callee9","walletAddress","activeClaimConditionId","_context9","_x13","_getTokenDecimals","_callee10","_context10","detectContractFeature","resolve","_prepareClaim2","_callee12","checkERC20Allowance","address","_yield$Promise$all9","_yield$Promise$all10","addressToClaim","activeClaimConditions","_this4","_args12","_context12","_callee11","_context11","_x14","_x15","_getClaimArguments","_callee13","destinationAddress","_context13","_x16","_x17","_x18","_getClaimTransaction","_callee14","_context14","call","getClaimArguments","t6","t7","overrides","t8","_x19","_x20","_x21","SnapshotFormatVersion","V1","V2"],"sourceRoot":""}